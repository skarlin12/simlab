<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GI Forklift Spatial Awareness Demo</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        :root {
            --space-sm: 0.75rem;
            --space-md: 1rem;
            --space-lg: 1.5rem;
            --space-xl: 2rem;
        }
        body {
            font-family: "Inter", -apple-system, sans-serif;
            background: #000000;
            color: #fff;
            min-height: 100vh;
            padding: clamp(28px, 3.5vw, 50px);
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-family: "Georgia", serif;
            color: #FFFFFF;
        }
        .header p {
            color: #888;
            font-size: 1.1rem;
        }
        .stats-bar {
            display: flex;
            justify-content: center;
            gap: 24px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        .stat {
            text-align: center;
            padding: 15px 25px;
            background: rgba(255,255,255,0.02);
            border-radius: 9px;
            border: 1px solid #4d4d4d;
        }
        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            font-family: "Chakra Petch", monospace;
            color: #FFFFFF;
        }
        .stat-label {
            font-size: 0.85rem;
            color: #888;
            margin-top: 5px;
        }
        .comparison-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            max-width: 1600px;
            margin: 0 auto;
        }
        .simulation-panel {
            background: rgba(255,255,255,0.02);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid #4d4d4d;
        }
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .panel-title {
            font-size: 1.3rem;
            font-weight: 600;
            font-family: "Inter", sans-serif;
        }
        .panel-title.rule-based { color: #888888; }
        .panel-title.gi-enabled { color: #FFFFFF; }
        .badge {
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.75rem;
            font-weight: 600;
        }
        .badge.reactive { background: rgba(242,216,205,0.15); color: #f2d8cd; }
        .badge.predictive { background: rgba(242,216,205,0.15); color: #f2d8cd; }
        .warehouse {
            position: relative;
            width: 700px;
            height: 500px;
            background: #1a1a2e;
            border-radius: 9px;
            overflow: hidden;
            margin: 0 auto;
        }
        .shelf {
            position: absolute;
            background:
                /* Horizontal shelf levels */
                repeating-linear-gradient(
                    0deg,
                    #2a2a3a 0px,
                    #2a2a3a 2px,
                    transparent 2px,
                    transparent 20px
                ),
                /* Vertical support beams on sides */
                linear-gradient(
                    90deg,
                    #d97706 0%,
                    #ea580c 8%,
                    #3a3a4a 8%,
                    #3a3a4a 92%,
                    #ea580c 92%,
                    #d97706 100%
                ),
                /* Stored boxes/pallets pattern */
                repeating-linear-gradient(
                    45deg,
                    #4a4a5a 0px,
                    #4a4a5a 8px,
                    #5a5a6a 8px,
                    #5a5a6a 16px
                );
            border-radius: 3px;
            border: 3px solid #b45309;
            box-shadow:
                inset 0 0 20px rgba(0, 0, 0, 0.5),
                0 4px 8px rgba(0, 0, 0, 0.6);
        }
        .lane-divider {
            position: absolute;
            border: 1px dashed rgba(255, 255, 255, 0.3);
            pointer-events: none;
        }
        .forklift {
            position: absolute;
            width: 35px;
            height: 50px;
            transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1);
            z-index: 10;
        }
        .forklift-body {
            width: 100%;
            height: 100%;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }
        .forklift.rule-based .forklift-body {
            background: linear-gradient(180deg, #ef4444 0%, #b91c1c 100%);
        }
        .forklift.gi-enabled .forklift-body {
            background: linear-gradient(180deg, #22c55e 0%, #15803d 100%);
        }
        .prediction-zone {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1);
            z-index: 5;
        }
        .prediction-zone.danger {
            background: rgba(239, 68, 68, 0.2);
            border: 3px dashed rgba(239, 68, 68, 0.8);
            animation: predictionPulse 1s infinite;
        }
        .prediction-zone.safe {
            background: rgba(34, 197, 94, 0.1);
            border: 2px dashed rgba(34, 197, 94, 0.3);
        }
        @keyframes predictionPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        .pedestrian {
            position: absolute;
            width: 25px;
            height: 25px;
            background: #fbbf24;
            border-radius: 50%;
            transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            z-index: 8;
        }
        .metrics-panel {
            margin-top: 15px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }
        .metric {
            background: rgba(255,255,255,0.04);
            padding: 12px;
            border-radius: 6px;
            text-align: center;
        }
        .metric-value {
            font-size: 1.5rem;
            font-weight: bold;
            font-family: "Chakra Petch", monospace;
        }
        .metric-value.danger { color: #888888; }
        .metric-value.success { color: #FFFFFF; }
        .metric-label {
            font-size: 0.75rem;
            color: #888;
            margin-top: 4px;
        }
        .alert-popup {
            position: absolute;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 600;
            animation: fadeInOut 2.5s forwards;
            z-index: 100;
            white-space: nowrap;
        }
        .alert-popup.danger {
            background: rgba(239, 68, 68, 0.95);
            color: white;
        }
        .alert-popup.warning {
            background: rgba(251, 191, 36, 0.95);
            color: black;
        }
        .alert-popup.safe {
            background: rgba(34, 197, 94, 0.95);
            color: white;
        }
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateY(10px); }
            15% { opacity: 1; transform: translateY(0); }
            85% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-10px); }
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 30px;
        }
        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1);
        }
        .btn-primary {
            background: #FFFFFF;
            color: #000000;
            border: 1px solid #FFFFFF;
        }
        .btn-primary:hover {
            background: #000000;
            color: #FFFFFF;
            transform: translateY(-2px);
        }
        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: white;
            border: 1px solid #4d4d4d;
        }
        .btn-secondary:hover {
            background: rgba(255,255,255,0.15);
        }
        .legend {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85rem;
            color: #888;
        }
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
        }
        .explanation {
            max-width: 1600px;
            margin: 40px auto 0;
            padding: 30px;
            background: rgba(255,255,255,0.02);
            border-radius: 12px;
            border: 1px solid #4d4d4d;
        }
        .explanation h2 {
            font-size: 1.5rem;
            margin-bottom: 20px;
            font-family: "Georgia", serif;
            color: #FFFFFF;
        }
        .explanation-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }
        .explanation-section h3 {
            font-size: 1.1rem;
            margin-bottom: 10px;
            font-family: "Inter", sans-serif;
            color: #888888;
        }
        .explanation-section h3.gi-title {
            color: #FFFFFF;
        }
        .explanation-section p {
            line-height: 1.6;
            color: #aaa;
            margin-bottom: 10px;
        }
        .explanation-section ul {
            margin-left: 20px;
            color: #aaa;
            line-height: 1.8;
        }
        .scenario {
            grid-column: 1 / -1;
            text-align: center;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            margin-bottom: 10px;
        }
        .scenario p {
            font-size: 1.05rem;
            color: #ccc;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Forklift Spatial Awareness Simulator</h1>
        <p>Side-by-side comparison: Rule-based reactive systems vs. GI-enabled spatiotemporal reasoning</p>
    </div>

    <div class="stats-bar">
        <div class="stat">
            <div class="stat-value">34,900</div>
            <div class="stat-label">Annual Serious Injuries</div>
        </div>
        <div class="stat">
            <div class="stat-value">$48K+</div>
            <div class="stat-label">Avg. Injury Cost</div>
        </div>
        <div class="stat">
            <div class="stat-value">85</div>
            <div class="stat-label">Annual Fatalities</div>
        </div>
        <div class="stat">
            <div class="stat-value">36%</div>
            <div class="stat-label">Injuries Involve Pedestrians</div>
        </div>
        <div class="stat">
            <div class="stat-value">18%</div>
            <div class="stat-label">Throughput Increase (GI)</div>
        </div>
    </div>

    <div class="comparison-container">
        <div class="simulation-panel">
            <div class="panel-header">
                <span class="panel-title rule-based">Human-Operated System</span>
                <span class="badge reactive">Manual Operation</span>
            </div>
            <div class="warehouse" id="warehouse-rule"></div>
            <div class="metrics-panel">
                <div class="metric">
                    <div class="metric-value danger" id="rule-near-misses">0</div>
                    <div class="metric-label">Near Misses</div>
                </div>
                <div class="metric">
                    <div class="metric-value danger" id="rule-collisions">0</div>
                    <div class="metric-label">Collisions</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="rule-throughput">0</div>
                    <div class="metric-label">Pallets Moved</div>
                </div>
            </div>
        </div>

        <div class="simulation-panel">
            <div class="panel-header">
                <span class="panel-title gi-enabled">GI-Enabled System</span>
                <span class="badge predictive">Predictive</span>
            </div>
            <div class="warehouse" id="warehouse-gi"></div>
            <div class="metrics-panel">
                <div class="metric">
                    <div class="metric-value success" id="gi-near-misses">0</div>
                    <div class="metric-label">Predicted Avoidances</div>
                </div>
                <div class="metric">
                    <div class="metric-value success" id="gi-collisions">0</div>
                    <div class="metric-label">Collisions</div>
                </div>
                <div class="metric">
                    <div class="metric-value success" id="gi-throughput">0</div>
                    <div class="metric-label">Pallets Moved</div>
                </div>
            </div>
        </div>
    </div>

    <div class="controls">
        <button class="btn btn-primary" id="startBtn">Start Simulation</button>
        <button class="btn btn-secondary" id="resetBtn">Reset</button>
    </div>

    <div class="legend">
        <div class="legend-item">
            <div class="legend-color" style="background: #ef4444;"></div>
            <span>Human-Operated Forklift (Manual)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #22c55e;"></div>
            <span>GI-Enabled Forklift (Predictive)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #fbbf24; border-radius: 50%;"></div>
            <span>Warehouse Pedestrians</span>
        </div>
    </div>

    <div class="explanation">
        <h2>Warehouse Forklift Safety Demo</h2>
        <div class="explanation-content">
            <div class="scenario">
                <p>This demo simulates operator-assisted forklift navigation in a busy warehouse environment. Pedestrians move through wide interior aisles while forklifts transport pallets between shelving units. Watch how the GI-enabled forklift (green) smoothly predicts and avoids pedestrians well in advance, while the rule-based forklift (red) reacts only when close, triggering frequent 5-second emergency stops.</p>
            </div>

            <div class="explanation-section">
                <h3>Human-Operated System</h3>
                <p>Traditional forklifts with basic obstacle detection react only to immediate threats:</p>
                <ul>
                    <li><strong>Manual Obstacle Detection:</strong> Detects pedestrians only when within 3 grid cells (too late for proactive avoidance)</li>
                    <li><strong>Long Emergency Stops:</strong> Stops for full 5 seconds per near-miss until all pedestrians clear 5+ cells away</li>
                    <li><strong>Collision Risk:</strong> Direct contact (same grid cell) causes crashes that end operations entirely</li>
                    <li><strong>Reduced Throughput:</strong> Frequent multi-second stops and occasional crashes severely impact productivity</li>
                </ul>
            </div>

            <div class="explanation-section">
                <h3 class="gi-title">GI-Enabled Predictive System</h3>
                <p>GI's spatiotemporal reasoning enables early collision prediction and smooth avoidance:</p>
                <ul>
                    <li><strong>Early Prediction:</strong> Simulates 30+ steps ahead, predicting pedestrian positions and potential conflicts before they occur</li>
                    <li><strong>Smooth Lane Changes:</strong> Changes lanes early when danger is predicted, maintaining smooth linear movement with no jerky reactions</li>
                    <li><strong>Proactive Avoidance:</strong> Adjusts path well before reaching pedestrians - forklift and pedestrian icons never overlap</li>
                    <li><strong>Intelligent Speed Control:</strong> Slightly slows during avoidance maneuvers for safety, then resumes normal pace</li>
                    <li><strong>18% Higher Throughput:</strong> Zero crashes, no emergency stops, maintains efficient continuous operation</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // ==================== GRID CONFIGURATION ====================
        const GRID_COLS = 35;
        const GRID_ROWS = 25;
        const CELL_SIZE = 20;  // pixels per grid cell

        const CONFIG = {
            // GI Forklift speeds (faster - confident movement with predictive awareness)
            GI_FORWARD_FRAMES: 3,          // Move 1 cell every 3 frames (450ms per cell)
            GI_AVOID_FRAMES: 4,            // Move 1 cell every 4 frames when avoiding (600ms per cell)
            GI_LANE_FRAMES: 3,             // Move 1 cell every 3 frames for lane change (450ms per cell)

            // Human-operated forklift speeds (more cautious)
            RULE_FORWARD_FRAMES: 4,        // Move 1 cell every 4 frames (600ms per cell)

            // Pedestrian movement
            PEDESTRIAN_FRAMES: 10,         // Move 1 cell every 10 frames (1500ms per cell = 2.5x slower)

            // Detection thresholds
            RULE_DETECTION_CELLS: 3,       // Rule-based detection distance (grid cells)
            RULE_COLLISION_CELLS: 0,       // Rule-based collision distance (same cell = 0 distance)
            GI_PREDICTION_LOOKAHEAD: 25,   // How many waypoints ahead to predict for pedestrian
            GI_DANGER_THRESHOLD: 8,        // Trigger lane change if predicted distance < 8 cells (early warning)
            NEAR_MISS_STOP_FRAMES: 33,     // How long rule-based stops (33 frames * 150ms = 5 seconds)
            UPDATE_INTERVAL: 150,          // Frame update time (ms) = slower for visibility
        };

        // ==================== GRID LAYOUT ====================
        // Wide aisles (5 cells each), compact shelves (5 cells each)
        const GRID_LAYOUT = {
            // Perimeters (4-5 cells wide)
            leftPerimeter: { lanes: [1, 2, 3, 4] },
            rightPerimeter: { lanes: [30, 31, 32, 33, 34] },
            topPerimeter: { lanes: [1, 2, 3] },
            bottomPerimeter: { lanes: [20, 21, 22, 23, 24] },

            // Interior aisles (5 cells wide each)
            leftAisle: { leftLane: 10, rightLane: 11, center: 12 },      // X = 10-14
            rightAisle: { leftLane: 20, rightLane: 21, center: 22 },     // X = 20-24
            horizontalAisle: { topLane: 9, bottomLane: 10, center: 11 }  // Y = 9-13
        };

        // Shelf cells (grid coordinates) - small and compact
        const SHELF_CELLS = [
            // Column 1: X = 5-9 (5 cells wide)
            { x: 5, y: 4, w: 5, h: 5 },    // Top shelf (Y: 4-8)
            { x: 5, y: 14, w: 5, h: 5 },   // Bottom shelf (Y: 14-18)

            // Column 2: X = 15-19 (5 cells wide)
            { x: 15, y: 4, w: 5, h: 5 },   // Top shelf
            { x: 15, y: 14, w: 5, h: 5 },  // Bottom shelf

            // Column 3: X = 25-29 (5 cells wide)
            { x: 25, y: 4, w: 5, h: 5 },   // Top shelf
            { x: 25, y: 14, w: 5, h: 5 },  // Bottom shelf
        ];

        // Visual shelves (for rendering) - convert grid to pixels
        const shelves = SHELF_CELLS.map(s => ({
            x: s.x * CELL_SIZE,
            y: s.y * CELL_SIZE,
            w: s.w * CELL_SIZE,
            h: s.h * CELL_SIZE
        }));

        // ==================== FORKLIFT PATHS (GRID COORDINATES) ====================
        // Comprehensive warehouse path: visits all 6 shelves across 3 columns
        // Demonstrates realistic pallet pickup/delivery operations
        // Uses LEFT lane (lower coordinate) for main travel
        const forkliftPath = [
            // START: Top left perimeter
            { gridX: 2, gridY: 2 },
            { gridX: 6, gridY: 2 },

            // SECTION 1: LEFT AISLE - Service Column 1 shelves (X=5-9)
            // Enter left interior aisle (X=10, left lane) and go DOWN
            { gridX: 10, gridY: 2 },
            { gridX: 10, gridY: 4 },   // Passing top shelf (Y=4-8)
            { gridX: 10, gridY: 6 },
            { gridX: 10, gridY: 8 },
            { gridX: 10, gridY: 9 },   // At horizontal aisle
            { gridX: 10, gridY: 11 },  // Cross horizontal aisle
            { gridX: 10, gridY: 14 },  // Passing bottom shelf (Y=14-18)
            { gridX: 10, gridY: 16 },
            { gridX: 10, gridY: 18 },
            { gridX: 10, gridY: 19 },  // Exit to bottom

            // SECTION 2: BOTTOM PERIMETER + HORIZONTAL - Service Column 2 shelves (X=15-19)
            { gridX: 12, gridY: 19 },
            { gridX: 15, gridY: 19 },  // Near column 2 bottom shelf
            { gridX: 17, gridY: 19 },
            { gridX: 20, gridY: 19 },  // Arrive at right aisle

            // SECTION 3: RIGHT AISLE - Service Column 3 shelves (X=25-29)
            // Travel UP right interior aisle (X=20, left lane)
            { gridX: 20, gridY: 17 },  // Passing bottom shelf (Y=14-18)
            { gridX: 20, gridY: 15 },
            { gridX: 20, gridY: 13 },
            { gridX: 20, gridY: 11 },  // At horizontal aisle
            { gridX: 20, gridY: 9 },   // Cross horizontal aisle
            { gridX: 20, gridY: 7 },   // Passing top shelf (Y=4-8)
            { gridX: 20, gridY: 5 },
            { gridX: 20, gridY: 3 },   // Exit to top

            // SECTION 4: TOP + HORIZONTAL - Return to service Column 2 from top
            { gridX: 17, gridY: 3 },
            { gridX: 15, gridY: 3 },   // Above column 2
            { gridX: 12, gridY: 3 },
            { gridX: 10, gridY: 3 },   // Back to left aisle

            // SECTION 5: LEFT AISLE - Second pass DOWN
            { gridX: 10, gridY: 5 },   // Second pass by column 1 top shelf
            { gridX: 10, gridY: 7 },
            { gridX: 10, gridY: 9 },   // At horizontal aisle

            // SECTION 6: HORIZONTAL AISLE (Y=9, top lane) - Service Column 2 shelves from middle
            { gridX: 12, gridY: 9 },
            { gridX: 15, gridY: 9 },   // Between column 2 shelves (can access both)
            { gridX: 17, gridY: 9 },
            { gridX: 20, gridY: 9 },   // Arrive at right aisle

            // SECTION 7: RIGHT AISLE - Second pass DOWN
            { gridX: 20, gridY: 11 },  // In horizontal aisle
            { gridX: 20, gridY: 13 },
            { gridX: 20, gridY: 15 },  // Second pass by column 3 bottom shelf
            { gridX: 20, gridY: 17 },
            { gridX: 20, gridY: 19 },  // Exit to bottom

            // SECTION 8: BOTTOM PERIMETER - Return to start
            { gridX: 17, gridY: 20 },
            { gridX: 12, gridY: 20 },
            { gridX: 7, gridY: 20 },
            { gridX: 3, gridY: 20 },

            // SECTION 9: LEFT PERIMETER - Return UP
            { gridX: 2, gridY: 17 },
            { gridX: 2, gridY: 14 },
            { gridX: 2, gridY: 11 },
            { gridX: 2, gridY: 7 },
            { gridX: 2, gridY: 4 },
            { gridX: 2, gridY: 2 },    // Back to start
        ];

        // ==================== PEDESTRIAN PATHS (GRID COORDINATES) ====================
        // Pedestrians stay in their lane and loop continuously in interior aisles
        const pedestrianPaths = [
            // Pedestrian 1: Left vertical interior aisle, left lane (X=10)
            {
                loop: [
                    { gridX: 10, gridY: 19 },  // Start at bottom
                    { gridX: 10, gridY: 17 },
                    { gridX: 10, gridY: 14 },
                    { gridX: 10, gridY: 11 },
                    { gridX: 10, gridY: 9 },
                    { gridX: 10, gridY: 7 },
                    { gridX: 10, gridY: 5 },
                    { gridX: 10, gridY: 3 },  // Top
                    { gridX: 10, gridY: 5 },
                    { gridX: 10, gridY: 7 },
                    { gridX: 10, gridY: 9 },
                    { gridX: 10, gridY: 11 },
                    { gridX: 10, gridY: 14 },
                    { gridX: 10, gridY: 17 },
                ],
                startIndex: 3  // Start at middle position to reduce initial collision
            },
            // Pedestrian 2: Right vertical interior aisle, left lane (X=20)
            {
                loop: [
                    { gridX: 20, gridY: 19 },  // Start at bottom
                    { gridX: 20, gridY: 17 },
                    { gridX: 20, gridY: 15 },
                    { gridX: 20, gridY: 13 },
                    { gridX: 20, gridY: 11 },
                    { gridX: 20, gridY: 9 },
                    { gridX: 20, gridY: 7 },
                    { gridX: 20, gridY: 5 },
                    { gridX: 20, gridY: 3 },  // Top
                    { gridX: 20, gridY: 5 },
                    { gridX: 20, gridY: 7 },
                    { gridX: 20, gridY: 9 },
                    { gridX: 20, gridY: 11 },
                    { gridX: 20, gridY: 13 },
                    { gridX: 20, gridY: 15 },
                    { gridX: 20, gridY: 17 },
                ],
                startIndex: 5 // Start at different position for variety
            },
        ];

        // ==================== SIMULATION STATE ====================
        let running = false;
        let updateInterval = null;
        let simTime = 0;

        let metrics = {
            rule: { nearMisses: 0, collisions: 0, throughput: 0 },
            gi: { nearMisses: 0, collisions: 0, throughput: 0 }
        };

        let ruleForklift = null;
        let giForklift = null;
        let pedestrians = [];

        // ==================== HELPER FUNCTIONS ====================

        function gridToPixel(gridX, gridY) {
            return {
                x: gridX * CELL_SIZE + CELL_SIZE / 2,  // Center of cell
                y: gridY * CELL_SIZE + CELL_SIZE / 2
            };
        }

        function isValidGridPosition(gridX, gridY) {
            // Check bounds
            if (gridX < 0 || gridX >= GRID_COLS || gridY < 0 || gridY >= GRID_ROWS) {
                return false;
            }

            // Check shelf collision (grid cells occupied by shelves)
            for (const shelf of SHELF_CELLS) {
                if (gridX >= shelf.x && gridX < shelf.x + shelf.w &&
                    gridY >= shelf.y && gridY < shelf.y + shelf.h) {
                    return false;
                }
            }

            return true;
        }

        function manhattanDistance(gridX1, gridY1, gridX2, gridY2) {
            return Math.abs(gridX2 - gridX1) + Math.abs(gridY2 - gridY1);
        }

        function hasLineOfSight(x1, y1, x2, y2) {
            // Bresenham's line algorithm - checks all grid cells between two points
            // Returns false if ANY shelf cell blocks the path

            const dx = Math.abs(x2 - x1);
            const dy = Math.abs(y2 - y1);
            const sx = x1 < x2 ? 1 : -1;
            const sy = y1 < y2 ? 1 : -1;
            let err = dx - dy;

            let currentX = x1;
            let currentY = y1;

            while (true) {
                // Don't check start and end points, only intermediate cells
                if ((currentX !== x1 || currentY !== y1) && (currentX !== x2 || currentY !== y2)) {
                    // Check if this cell is a shelf
                    for (const shelf of SHELF_CELLS) {
                        if (currentX >= shelf.x && currentX < shelf.x + shelf.w &&
                            currentY >= shelf.y && currentY < shelf.y + shelf.h) {
                            return false; // Shelf blocks line of sight
                        }
                    }
                }

                // Reached end point
                if (currentX === x2 && currentY === y2) break;

                const e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    currentX += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    currentY += sy;
                }
            }

            return true; // Path is clear
        }

        function isApproachingPedestrian(forkliftX, forkliftY, dirX, dirY, pedX, pedY) {
            // Calculate vector from forklift to pedestrian
            const toPedX = pedX - forkliftX;
            const toPedY = pedY - forkliftY;

            // Dot product: positive = approaching, negative = moving away
            const dotProduct = (dirX * toPedX) + (dirY * toPedY);

            return dotProduct > 0; // Only true if moving toward pedestrian
        }

        function canChangeLane(forklift, isVertical) {
            // Check all 3 cells needed for lane change
            for (let i = 1; i <= 3; i++) {
                const testX = isVertical ? forklift.gridX + i : forklift.gridX;
                const testY = isVertical ? forklift.gridY : forklift.gridY + i;
                if (!isValidGridPosition(testX, testY)) {
                    return false;  // Any invalid cell blocks lane change
                }
            }
            return true;
        }

        function checkShelfProximity(forklift, type) {
            if (!forklift.shelfsPassed) forklift.shelfsPassed = {};

            SHELF_CELLS.forEach((shelf, idx) => {
                const shelfCenterX = shelf.x + Math.floor(shelf.w / 2);
                const shelfCenterY = shelf.y + Math.floor(shelf.h / 2);
                const dist = manhattanDistance(forklift.gridX, forklift.gridY, shelfCenterX, shelfCenterY);

                // Close enough to count as passing (delivering/picking up) - within 6 grid cells
                if (dist < 6) {
                    const key = `shelf_${idx}`;
                    // 8-second cooldown per shelf (allows faster throughput accumulation)
                    if (!forklift.shelfsPassed[key] || simTime - forklift.shelfsPassed[key] > 8000) {
                        metrics[type].throughput++;
                        forklift.shelfsPassed[key] = simTime;
                    }
                }
            });
        }

        function showAlert(containerId, message, type, x, y) {
            const container = document.getElementById(containerId);
            const alert = document.createElement('div');
            alert.className = `alert-popup ${type}`;
            alert.textContent = message;
            alert.style.left = x + 'px';
            alert.style.top = y + 'px';
            container.appendChild(alert);
            setTimeout(() => alert.remove(), 2500);
        }

        function updateMetricsDisplay() {
            document.getElementById('rule-near-misses').textContent = metrics.rule.nearMisses;
            document.getElementById('rule-collisions').textContent = metrics.rule.collisions;
            document.getElementById('rule-throughput').textContent = metrics.rule.throughput;
            document.getElementById('gi-near-misses').textContent = metrics.gi.nearMisses;
            document.getElementById('gi-collisions').textContent = metrics.gi.collisions;
            document.getElementById('gi-throughput').textContent = metrics.gi.throughput;
        }

        // ==================== INITIALIZATION ====================

        function initWarehouse(containerId, isGI) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';

            // Add shelves
            shelves.forEach(shelf => {
                const el = document.createElement('div');
                el.className = 'shelf';
                el.style.left = shelf.x + 'px';
                el.style.top = shelf.y + 'px';
                el.style.width = shelf.w + 'px';
                el.style.height = shelf.h + 'px';
                container.appendChild(el);
            });

            // Add forklift
            const forklift = document.createElement('div');
            forklift.className = `forklift ${isGI ? 'gi-enabled' : 'rule-based'}`;
            forklift.id = isGI ? 'gi-forklift' : 'rule-forklift';
            forklift.innerHTML = '<div class="forklift-body">üèóÔ∏è</div>';
            container.appendChild(forklift);

            // Add pedestrians
            pedestrians.forEach((p, i) => {
                const ped = document.createElement('div');
                ped.className = 'pedestrian';
                ped.id = `${isGI ? 'gi' : 'rule'}-ped-${i}`;
                ped.textContent = 'üë∑';
                container.appendChild(ped);
            });
        }

        function initPedestrians() {
            pedestrians = [];
            pedestrianPaths.forEach((pathDef, i) => {
                const startPos = pathDef.loop[pathDef.startIndex];
                pedestrians.push({
                    gridX: startPos.gridX,
                    gridY: startPos.gridY,
                    loop: pathDef.loop,
                    waypointIdx: (pathDef.startIndex + 1) % pathDef.loop.length,
                    frameCounter: 0,
                    hasTriggeredRuleEvent: false,
                    hasTriggeredGIEvent: false,
                    ruleEventCooldown: 0,
                    giEventCooldown: 0,
                });
            });
        }

        function resetSimulation() {
            running = false;
            if (updateInterval) clearInterval(updateInterval);

            simTime = 0;
            metrics = {
                rule: { nearMisses: 0, collisions: 0, throughput: 0 },
                gi: { nearMisses: 0, collisions: 0, throughput: 0 }
            };

            // Validate forklift path waypoints
            let invalidWaypoints = [];
            forkliftPath.forEach((waypoint, idx) => {
                if (!isValidGridPosition(waypoint.gridX, waypoint.gridY)) {
                    invalidWaypoints.push(`Waypoint ${idx}: (${waypoint.gridX}, ${waypoint.gridY})`);
                }
            });
            if (invalidWaypoints.length > 0) {
                console.error('Invalid forklift path waypoints:', invalidWaypoints);
            }

            // Initialize forklifts at start position (grid coordinates)
            ruleForklift = {
                gridX: forkliftPath[0].gridX,
                gridY: forkliftPath[0].gridY,
                waypointIdx: 1,
                frameCounter: 0,
                crashed: false,
                stopFrames: 0,
                shelfsPassed: {},
                lastMoveX: 0,
                lastMoveY: 1  // Initially moving down/right
            };

            giForklift = {
                gridX: forkliftPath[0].gridX,
                gridY: forkliftPath[0].gridY,
                waypointIdx: 1,
                frameCounter: 0,
                currentLane: 'left', // 'left' or 'right'
                state: 'FORWARD', // 'FORWARD', 'LANE_CHANGE_PERPENDICULAR', 'LANE_RETURN'
                shelfsPassed: {},
                lastMoveX: 0,
                lastMoveY: 1,  // Initially moving down/right
                laneCommitFrames: 0,  // Countdown timer for commitment period
                laneChangeFrames: 0,  // NEW: Counter for perpendicular movement (0-3)
                predictionDirection: { x: 0, y: 1 },  // NEW: Locked during avoidance
                stableDirection: { x: 0, y: 1 },  // Last known stable movement direction
                stuckCounter: 0,  // Track frames without movement
                lastGridX: forkliftPath[0].gridX,
                lastGridY: forkliftPath[0].gridY,
                lastWaypointIdx: 1  // NEW: Track waypoint changes for stuck detection
            };

            // Initialize pedestrians
            initPedestrians();

            // Clear crash visuals
            const rulePanel = document.getElementById('warehouse-rule');
            rulePanel.style.border = '';
            rulePanel.style.opacity = '';

            // Build warehouses
            initWarehouse('warehouse-rule', false);
            initWarehouse('warehouse-gi', true);
            updateMetricsDisplay();

            document.getElementById('startBtn').textContent = 'Start Simulation';
        }

        // ==================== UPDATE LOOPS ====================

        function updatePedestrians() {
            pedestrians.forEach((p, i) => {
                // COSMETIC: Freeze pedestrians if rule-based forklift crashed
                if (ruleForklift && ruleForklift.crashed) {
                    // Just update visuals, no movement
                    const pos = gridToPixel(p.gridX, p.gridY);
                    ['rule', 'gi'].forEach(type => {
                        const el = document.getElementById(`${type}-ped-${i}`);
                        if (el) {
                            el.style.left = (pos.x - 12) + 'px';
                            el.style.top = (pos.y - 12) + 'px';
                        }
                    });
                    return;
                }

                p.frameCounter++;

                // Get current target waypoint
                const target = p.loop[p.waypointIdx];

                // Already at target? Advance waypoint
                if (p.gridX === target.gridX && p.gridY === target.gridY) {
                    p.waypointIdx = (p.waypointIdx + 1) % p.loop.length;
                    return;
                }

                // Move 1 cell every PEDESTRIAN_FRAMES
                if (p.frameCounter % CONFIG.PEDESTRIAN_FRAMES === 0) {
                    const dx = target.gridX - p.gridX;
                    const dy = target.gridY - p.gridY;

                    // Move 1 cell toward target
                    if (Math.abs(dx) > Math.abs(dy)) {
                        p.gridX += Math.sign(dx);
                    } else {
                        p.gridY += Math.sign(dy);
                    }
                }

                // Cooldown timers
                if (p.ruleEventCooldown > 0) {
                    p.ruleEventCooldown -= CONFIG.UPDATE_INTERVAL;
                    if (p.ruleEventCooldown <= 0) p.hasTriggeredRuleEvent = false;
                }
                if (p.giEventCooldown > 0) {
                    p.giEventCooldown -= CONFIG.UPDATE_INTERVAL;
                    if (p.giEventCooldown <= 0) p.hasTriggeredGIEvent = false;
                }

                // Update visuals in both warehouses
                const pos = gridToPixel(p.gridX, p.gridY);
                ['rule', 'gi'].forEach(type => {
                    const el = document.getElementById(`${type}-ped-${i}`);
                    if (el) {
                        el.style.left = (pos.x - 12) + 'px';
                        el.style.top = (pos.y - 12) + 'px';
                    }
                });
            });
        }

        function updateRuleForklift() {
            const f = ruleForklift;
            if (f.crashed) return;

            f.frameCounter++;

            // Handle stop frames
            if (f.stopFrames > 0) {
                f.stopFrames--;

                // Only check for early resume after minimum stop time (2 seconds = 13 frames)
                // This prevents immediate re-triggering
                const minStopFrames = 13;
                const canEarlyResume = (CONFIG.NEAR_MISS_STOP_FRAMES - f.stopFrames) >= minStopFrames;

                if (canEarlyResume) {
                    // Check if all pedestrians are far away (7+ cells for safety margin)
                    let allClear = true;
                    for (const p of pedestrians) {
                        const dist = manhattanDistance(f.gridX, f.gridY, p.gridX, p.gridY);
                        if (dist < 7) {
                            allClear = false;
                            break;
                        }
                    }

                    if (allClear) {
                        f.stopFrames = 0; // Resume early
                    }
                }

                // Update visual only (no movement)
                updateForkliftVisual(f, 'rule');
                return;
            }

            // Get current target waypoint
            const target = forkliftPath[f.waypointIdx];

            // Already at target? Advance waypoint
            if (f.gridX === target.gridX && f.gridY === target.gridY) {
                f.waypointIdx = (f.waypointIdx + 1) % forkliftPath.length;
                return;
            }

            // Check for pedestrians (reactive only - current position)
            for (const p of pedestrians) {
                if (p.hasTriggeredRuleEvent) continue;

                const pedDist = manhattanDistance(f.gridX, f.gridY, p.gridX, p.gridY);

                // Same cell = collision
                if (f.gridX === p.gridX && f.gridY === p.gridY) {
                    // COLLISION - end simulation
                    metrics.rule.collisions++;
                    f.crashed = true;
                    p.hasTriggeredRuleEvent = true;
                    p.ruleEventCooldown = 10000;

                    const pos = gridToPixel(f.gridX, f.gridY);
                    showAlert('warehouse-rule', 'üí• COLLISION - OPERATIONS ENDED', 'danger', pos.x, pos.y - 50);

                    const rulePanel = document.getElementById('warehouse-rule');
                    rulePanel.style.border = '3px solid #ef4444';
                    rulePanel.style.opacity = '0.7';

                    const el = document.getElementById('rule-forklift');
                    if (el) el.style.opacity = '0.5';
                    return;
                } else if (pedDist <= CONFIG.RULE_DETECTION_CELLS) {
                    // Check if we're actually moving toward the pedestrian
                    const target = forkliftPath[f.waypointIdx];
                    const dirX = target.gridX - f.gridX;
                    const dirY = target.gridY - f.gridY;

                    // Normalize direction to unit vector
                    const moveDir = {
                        x: Math.abs(dirX) > Math.abs(dirY) ? Math.sign(dirX) : 0,
                        y: Math.abs(dirY) > Math.abs(dirX) ? Math.sign(dirY) : 0
                    };

                    // Only stop if approaching the pedestrian
                    if (isApproachingPedestrian(f.gridX, f.gridY, moveDir.x, moveDir.y, p.gridX, p.gridY)) {
                        // NEAR MISS - stop and wait (within 3 cells AND approaching)
                        metrics.rule.nearMisses++;
                        f.stopFrames = CONFIG.NEAR_MISS_STOP_FRAMES;
                        p.hasTriggeredRuleEvent = true;
                        p.ruleEventCooldown = 6000;

                        const pos = gridToPixel(f.gridX, f.gridY);
                        showAlert('warehouse-rule', '‚ö† NEAR MISS - STOPPING 5s', 'warning', pos.x, pos.y - 50);
                        return;
                    }
                }
            }

            // Move forward: 1 cell every RULE_FORWARD_FRAMES
            if (f.frameCounter % CONFIG.RULE_FORWARD_FRAMES === 0) {
                const dx = target.gridX - f.gridX;
                const dy = target.gridY - f.gridY;

                let moveX = 0;
                let moveY = 0;

                // Move 1 cell toward target
                if (Math.abs(dx) > Math.abs(dy)) {
                    moveX = Math.sign(dx);
                } else {
                    moveY = Math.sign(dy);
                }

                // Apply grid movement
                const newGridX = f.gridX + moveX;
                const newGridY = f.gridY + moveY;

                // Validate position - if invalid, skip to next waypoint
                if (isValidGridPosition(newGridX, newGridY)) {
                    f.gridX = newGridX;
                    f.gridY = newGridY;
                    f.lastMoveX = moveX;
                    f.lastMoveY = moveY;
                } else {
                    // Position blocked, try advancing to next waypoint
                    console.warn(`Rule forklift blocked at (${newGridX}, ${newGridY}), advancing waypoint`);
                    f.waypointIdx = (f.waypointIdx + 1) % forkliftPath.length;
                }
            }

            // Update visual
            updateForkliftVisual(f, 'rule');
        }

        function updateForkliftVisual(forklift, type) {
            const pos = gridToPixel(forklift.gridX, forklift.gridY);
            const el = document.getElementById(`${type}-forklift`);
            if (el) {
                el.style.left = (pos.x - 17) + 'px';
                el.style.top = (pos.y - 25) + 'px';

                // For GI forklift: use stable direction to avoid jitter
                // For rule-based: use last actual movement
                if (type === 'gi' && forklift.stableDirection) {
                    if (forklift.stableDirection.x !== 0 || forklift.stableDirection.y !== 0) {
                        const angle = Math.atan2(forklift.stableDirection.y, forklift.stableDirection.x) * 180 / Math.PI;
                        el.style.transform = `rotate(${angle + 90}deg)`;
                    }
                } else {
                    // Rule-based forklift: use last actual movement
                    if (forklift.lastMoveX !== 0 || forklift.lastMoveY !== 0) {
                        const angle = Math.atan2(forklift.lastMoveY, forklift.lastMoveX) * 180 / Math.PI;
                        el.style.transform = `rotate(${angle + 90}deg)`;
                    }
                }
            }
        }

        function getLaneAdjustedTarget(forklift) {
            const target = forkliftPath[forklift.waypointIdx];

            // If in left lane (default), return original target
            if (forklift.currentLane === 'left') {
                return { gridX: target.gridX, gridY: target.gridY };
            }

            // If in right lane, we've moved 3 cells perpendicular, so stay at that offset
            // Calculate where we should be (3 cells perpendicular from original path)
            const isVertical = Math.abs(forklift.predictionDirection.y) > Math.abs(forklift.predictionDirection.x);

            let adjustedX = target.gridX;
            let adjustedY = target.gridY;

            if (isVertical) {
                // Vertical movement: we moved 3 cells right, so target should also be 3 right
                adjustedX = target.gridX + 3;
            } else {
                // Horizontal movement: we moved 3 cells down, so target should also be 3 down
                adjustedY = target.gridY + 3;
            }

            // Validate the adjusted target is reachable
            if (!isValidGridPosition(adjustedX, adjustedY)) {
                // Adjusted target is invalid (shelf/out of bounds)
                // Force return to left lane to break circular dependency
                forklift.currentLane = 'left';
                forklift.laneCommitFrames = 0;
                forklift.laneChangeFrames = 0;
                return { gridX: target.gridX, gridY: target.gridY };
            }

            return { gridX: adjustedX, gridY: adjustedY };
        }

        function updateGIForklift() {
            const f = giForklift;
            f.frameCounter++;

            // Decrement commitment counter if active
            if (f.laneCommitFrames > 0) {
                f.laneCommitFrames--;
            }

            // NEW: Decrement lane change counter if active
            if (f.laneChangeFrames > 0) {
                f.laneChangeFrames--;
            }

            // Get current target waypoint (adjusted for lane)
            const adjustedTarget = getLaneAdjustedTarget(f);

            // Already at target? Advance waypoint
            if (f.gridX === adjustedTarget.gridX && f.gridY === adjustedTarget.gridY) {
                const oldWaypointIdx = f.waypointIdx;
                f.waypointIdx = (f.waypointIdx + 1) % forkliftPath.length;

                // If in lane commitment, check if next waypoint requires different axis
                if (f.laneCommitFrames > 0) {
                    const oldWaypoint = forkliftPath[oldWaypointIdx];
                    const newWaypoint = forkliftPath[f.waypointIdx];
                    const oldDx = oldWaypoint.gridX - f.gridX;
                    const oldDy = oldWaypoint.gridY - f.gridY;
                    const newDx = newWaypoint.gridX - f.gridX;
                    const newDy = newWaypoint.gridY - f.gridY;

                    const oldIsVertical = Math.abs(oldDy) > Math.abs(oldDx);
                    const newIsVertical = Math.abs(newDy) > Math.abs(newDx);

                    // If axis changed at waypoint boundary (corner turn), clear commitment
                    if (oldIsVertical !== newIsVertical) {
                        f.currentLane = 'left';
                        f.laneCommitFrames = 0;
                        f.laneChangeFrames = 0;
                        console.log('GI forklift: corner turn detected, clearing lane commitment');
                    }
                }

                // Don't reset lane here - let CASE 3 handle return to left lane when safe
                f.state = 'FORWARD';
                return;
            }

            // Determine direction to ORIGINAL target (not adjusted - prevents circular dependency)
            const originalTarget = forkliftPath[f.waypointIdx];
            const dx = originalTarget.gridX - f.gridX;
            const dy = originalTarget.gridY - f.gridY;
            const isVertical = Math.abs(dy) > Math.abs(dx);

            // Update predictionDirection ONLY when NOT in avoidance (lock during BOTH phases)
            // This prevents oscillation during committed forward movement
            if (f.laneChangeFrames === 0 && f.laneCommitFrames === 0) {
                if (Math.abs(dx) > 0 || Math.abs(dy) > 0) {
                    const newDirX = Math.abs(dx) > Math.abs(dy) ? Math.sign(dx) : 0;
                    const newDirY = Math.abs(dy) > Math.abs(dx) ? Math.sign(dy) : 0;

                    f.predictionDirection.x = newDirX;
                    f.predictionDirection.y = newDirY;
                }
            }

            // stableDirection (for visual rotation) follows predictionDirection
            // This ensures consistent visual orientation during avoidance
            f.stableDirection.x = f.predictionDirection.x;
            f.stableDirection.y = f.predictionDirection.y;

            // PREDICTIVE COLLISION DETECTION - REDESIGNED
            // Phase 1: Filter to visible pedestrians (line-of-sight on CURRENT positions)
            // Phase 2: Check directional awareness (only approaching, not moving away)
            // Phase 3: Unified detection (immediate proximity OR predicted collision)
            // Phase 4: Single alert trigger point

            let predictedDanger = false;
            let dangerType = null; // 'immediate' or 'predicted'
            let triggeredPedestrian = null;

            // PHASE 1: Filter to visible pedestrians only (check CURRENT positions)
            const visiblePedestrians = [];
            for (const p of pedestrians) {
                if (hasLineOfSight(f.gridX, f.gridY, p.gridX, p.gridY)) {
                    visiblePedestrians.push(p);
                }
            }

            // PHASE 2 & 3: Unified detection on visible pedestrians
            for (const p of visiblePedestrians) {
                // Check if approaching (skip if moving away)
                if (!isApproachingPedestrian(f.gridX, f.gridY, f.predictionDirection.x, f.predictionDirection.y, p.gridX, p.gridY)) {
                    continue; // Moving away, skip this pedestrian
                }

                // Check immediate proximity FIRST (0-6 cells = highest priority)
                const currentDist = manhattanDistance(f.gridX, f.gridY, p.gridX, p.gridY);
                if (currentDist <= 6) {
                    predictedDanger = true;
                    dangerType = 'immediate';
                    triggeredPedestrian = p;
                    break; // Immediate danger takes priority
                }

                // Check predictive collision (4-20 cells ahead)
                let willCollide = false;
                for (let step = 1; step <= 20; step++) {
                    const futureX = f.gridX + f.predictionDirection.x * step;
                    const futureY = f.gridY + f.predictionDirection.y * step;

                    // Simulate pedestrian movement (dynamically calculate speed ratio)
                    // Pedestrian speed ratio = PEDESTRIAN_FRAMES / GI_FORWARD_FRAMES
                    const speedRatio = CONFIG.PEDESTRIAN_FRAMES / CONFIG.GI_FORWARD_FRAMES;
                    const pedTarget = p.loop[p.waypointIdx];
                    const pedDx = pedTarget.gridX - p.gridX;
                    const pedDy = pedTarget.gridY - p.gridY;
                    const pedSteps = Math.floor(step / speedRatio);

                    let pedFutureX = p.gridX;
                    let pedFutureY = p.gridY;

                    if (pedDx !== 0 || pedDy !== 0) {
                        const pedDirX = Math.abs(pedDx) > Math.abs(pedDy) ? Math.sign(pedDx) : 0;
                        const pedDirY = Math.abs(pedDy) > Math.abs(pedDx) ? Math.sign(pedDy) : 0;
                        pedFutureX += pedDirX * pedSteps;
                        pedFutureY += pedDirY * pedSteps;
                    }

                    const futureDist = manhattanDistance(futureX, futureY, pedFutureX, pedFutureY);

                    if (futureDist <= 3) {
                        // Predicted collision found (no need to check line-of-sight again)
                        willCollide = true;
                        break;
                    }
                }

                if (willCollide) {
                    predictedDanger = true;
                    dangerType = 'predicted';
                    triggeredPedestrian = p;
                    break;
                }
            }

            // PHASE 4: Alert trigger point (separate from detection)
            // CRITICAL: Detection happens regardless of event flag - avoidance ALWAYS executes
            // Event flag ONLY controls alert display and metrics counting
            if (predictedDanger && triggeredPedestrian && !triggeredPedestrian.hasTriggeredGIEvent) {
                metrics.gi.nearMisses++;
                triggeredPedestrian.hasTriggeredGIEvent = true;
                triggeredPedestrian.giEventCooldown = 12000;

                const pos = gridToPixel(f.gridX, f.gridY);
                const message = dangerType === 'immediate'
                    ? '‚úì CLOSE PROXIMITY - AVOIDING'
                    : '‚úì EARLY PREDICTION - AVOIDING';
                showAlert('warehouse-gi', message, 'safe', pos.x, pos.y - 50);
            }
            // NOTE: predictedDanger flag is still set and used by state machine below
            // Avoidance behavior executes regardless of alert display

            // Determine if in an interior aisle (where lane changing is allowed)
            const inInteriorAisle = (f.gridX >= 10 && f.gridX <= 14) ||
                                   (f.gridX >= 20 && f.gridX <= 24) ||
                                   (f.gridY >= 9 && f.gridY <= 13);

            // STATE MACHINE with hysteresis
            let moveX = 0;
            let moveY = 0;

            // Use slower speed when avoiding (predictedDanger = true)
            const forwardFrames = predictedDanger ? CONFIG.GI_AVOID_FRAMES : CONFIG.GI_FORWARD_FRAMES;

            // CASE 1: Active lane change in progress (perpendicular movement phase)
            if (f.laneChangeFrames > 0) {
                // Continue moving perpendicular to achieve full 3-cell separation
                const perpIsVertical = Math.abs(f.predictionDirection.y) > Math.abs(f.predictionDirection.x);

                // Direction based on target lane: 'right' = positive, 'left' = negative
                const direction = f.currentLane === 'right' ? 1 : -1;

                // Add speed control: only move every GI_LANE_FRAMES
                if (f.frameCounter % CONFIG.GI_LANE_FRAMES === 0) {
                    if (perpIsVertical) {
                        moveX = direction;  // Move right (+1) or left (-1)
                    } else {
                        moveY = direction;  // Move down (+1) or up (-1)
                    }
                }
            }
            // CASE 2: Committed to lane (forward movement phase)
            else if (f.laneCommitFrames > 0) {
                // Forward movement in adjusted lane
                const commitAdjustedTarget = getLaneAdjustedTarget(f);
                const commitDx = commitAdjustedTarget.gridX - f.gridX;
                const commitDy = commitAdjustedTarget.gridY - f.gridY;

                // Move toward the adjusted target
                if (f.frameCounter % forwardFrames === 0) {
                    if (Math.abs(commitDx) > Math.abs(commitDy)) {
                        moveX = Math.sign(commitDx);
                    } else {
                        moveY = Math.sign(commitDy);
                    }
                }
            }
            // CASE 3: Prediction says danger AND we're in left lane AND not already changing lanes
            else if (predictedDanger && f.currentLane === 'left' && inInteriorAisle) {
                // PRE-VALIDATE: Check if lane change destination is valid
                const perpIsVertical = Math.abs(f.predictionDirection.y) > Math.abs(f.predictionDirection.x);
                if (canChangeLane(f, perpIsVertical)) {
                    // Start lane change sequence: 3 frames of perpendicular movement
                    // This achieves 3 cells of lateral separation before resuming forward

                    // Execute first perpendicular move
                    if (perpIsVertical) {
                        moveX = 1;  // Move right to right lane
                    } else {
                        moveY = 1;  // Move down to bottom lane
                    }

                    // Set lane change counter for 2 more frames (3 total including this one)
                    // Note: Decrement happens before check, so counter=3 gives us 2 more executions
                    f.laneChangeFrames = 3;

                    // Switch to right lane immediately
                    f.currentLane = 'right';

                    // Commit to staying in right lane for 80 frames AFTER lane change completes
                    f.laneCommitFrames = 80 + f.laneChangeFrames;  // Total: 83 frames

                } else {
                    // Can't change lanes (shelf edge or obstacle) - slow down instead
                    // Continue forward at reduced speed (GI_AVOID_FRAMES) in left lane
                    if (f.frameCounter % CONFIG.GI_AVOID_FRAMES === 0) {
                        if (Math.abs(dx) > Math.abs(dy)) {
                            moveX = Math.sign(dx);
                        } else {
                            moveY = Math.sign(dy);
                        }
                    }
                    // Stay in left lane, no commitment change
                }
            }
            // CASE 4: No danger AND we're in right lane AND commitment expired AND not already changing
            else if (!predictedDanger && f.currentLane === 'right' && inInteriorAisle && f.laneCommitFrames === 0) {
                // Start return to left lane (perpendicular movement)
                const perpIsVertical = Math.abs(f.predictionDirection.y) > Math.abs(f.predictionDirection.x);

                // Execute first perpendicular move back
                if (perpIsVertical) {
                    moveX = -1;  // Move left back to left lane
                } else {
                    moveY = -1;  // Move up to top lane
                }

                // Set lane change counter for 2 more frames (3 total including this one)
                f.laneChangeFrames = 3;

                // Switch to left lane immediately
                f.currentLane = 'left';

                // Commit to staying in left lane for 30 frames AFTER return completes
                f.laneCommitFrames = 30 + f.laneChangeFrames;  // Total: 33 frames
            }
            // CASE 5: Normal forward movement
            else {
                const normalAdjustedTarget = getLaneAdjustedTarget(f);
                const normalDx = normalAdjustedTarget.gridX - f.gridX;
                const normalDy = normalAdjustedTarget.gridY - f.gridY;

                if (f.frameCounter % forwardFrames === 0) {
                    if (Math.abs(normalDx) > Math.abs(normalDy)) {
                        moveX = Math.sign(normalDx);
                    } else {
                        moveY = Math.sign(normalDy);
                    }
                }
            }

            // Apply grid movement
            if (moveX !== 0 || moveY !== 0) {
                const newGridX = f.gridX + moveX;
                const newGridY = f.gridY + moveY;

                // Validate: stay within bounds and avoid shelves
                if (isValidGridPosition(newGridX, newGridY)) {
                    f.gridX = newGridX;
                    f.gridY = newGridY;
                    f.lastMoveX = moveX;
                    f.lastMoveY = moveY;
                } else {
                    // Position blocked
                    // CRITICAL: Don't reset lane if in active avoidance (would cancel collision avoidance!)
                    if (f.laneCommitFrames === 0 && f.laneChangeFrames === 0) {
                        // Not in active avoidance - safe to reset lane and advance waypoint
                        console.warn(`GI forklift blocked at (${newGridX}, ${newGridY}), advancing waypoint`);
                        f.currentLane = 'left';
                        f.waypointIdx = (f.waypointIdx + 1) % forkliftPath.length;
                    }
                    // If in active avoidance, just skip this move and continue on next frame
                }
            }

            // Stuck detection: waypoint hasn't advanced in 30 frames
            if (f.waypointIdx === f.lastWaypointIdx) {
                f.stuckCounter++;
                if (f.stuckCounter > 30) {
                    console.warn(`GI forklift stuck at waypoint ${f.waypointIdx}, resetting lane`);
                    f.currentLane = 'left';
                    f.laneCommitFrames = 0;
                    f.laneChangeFrames = 0;
                    f.stuckCounter = 0;
                    f.waypointIdx = (f.waypointIdx + 1) % forkliftPath.length;
                }
            } else {
                f.stuckCounter = 0;
            }
            f.lastWaypointIdx = f.waypointIdx;

            // Update visual position
            updateForkliftVisual(f, 'gi');
        }

        function updateSimulation() {
            if (!running) return;

            simTime += CONFIG.UPDATE_INTERVAL;

            updatePedestrians();
            updateRuleForklift();
            updateGIForklift();

            // Check shelf proximity for pallet counting
            if (!ruleForklift.crashed) {
                checkShelfProximity(ruleForklift, 'rule');
            }
            checkShelfProximity(giForklift, 'gi');

            updateMetricsDisplay();
        }

        // ==================== EVENT LISTENERS ====================

        document.getElementById('startBtn').addEventListener('click', () => {
            if (running) {
                running = false;
                clearInterval(updateInterval);
                document.getElementById('startBtn').textContent = 'Resume';
            } else {
                running = true;
                document.getElementById('startBtn').textContent = 'Pause';
                updateInterval = setInterval(updateSimulation, CONFIG.UPDATE_INTERVAL);
            }
        });

        document.getElementById('resetBtn').addEventListener('click', resetSimulation);

        // Initialize on load
        resetSimulation();
    </script>
</body>
</html>
